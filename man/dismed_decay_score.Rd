% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dismed_decay_score.R
\name{dismed_decay_score}
\alias{dismed_decay_score}
\title{Calculate Distance-to-Median Composite Scores & Metrics with Decay Function}
\usage{
dismed_decay_score(
  data = .,
  composite_list,
  decay_rate = 0.5,
  digits = 3,
  return_metrics = FALSE,
  file = NULL,
  name = NULL
)
}
\arguments{
\item{data}{A dataframe object. This should be a structured dataset where
each column represents a variable and each row represents an observation.}

\item{composite_list}{A required \code{composite_list} object. Each name in
the list represents a composite variable, and the corresponding vector
contains the column names that are associated with the indicators
comprising said composite variable.}

\item{decay_rate}{A numeric value reflecting the decay rate (i.e.,
sensitivity) of the distance-to-median weighting schema. The default value
is set to 0.5.}

\item{digits}{The decimal places for the metrics to be rounded to. Default is
3. This argument is only relevant if \code{return_metrics = TRUE}.}

\item{return_metrics}{Logic to determine whether to return reliability and
validity metrics. Set to \code{TRUE} for a list of dataframes with
reliability and validity metrics.}

\item{file}{An optional file path. If specified, the results will be written
as a formatted excel workbook. This argument is only relevant if
\code{return_metrics = TRUE}.}
}
\value{
If \code{return_metrics = FALSE}, a dataframe identical to the input
 dataframe, with additional columns appended at the end, is returned. These
 new columns represent the calculated composite scores. If
 \code{return_metrics = TRUE}, a list containing the following dataframes is
 returned:
 \itemize{
 \item{\strong{Data}: }{A dataframe with the composite variables appended as new
 variables.}
 \item{\strong{Metrics}: }{A matrix of indicator loadings and weights metrics.}
 \item{\strong{Validity}: }{A matrix of composite reliability and validity
 metrics.}
}
}
\description{
Create composite scores of scales by specifying the indicators that go into
its respective composite variable. Composite scores are weighted based on the
indicators' distances to the median of all indicators. Indicators with
greater distance from the median (i.e., greater the absolute difference
between the median and the indicator) are downweighted based on a decay
function. Median composite scores are calculated as the median of the
indicators:

\deqn{M = median(I[1], I[2], ..., I[n])}{M = median(I[1], I[2], ..., I[n])}

If we denote the \eqn{j^{th}} indicator (\eqn{I}) for the \eqn{i^{th}} respondent
as \eqn{I[ij]}, the distance-to-median calculation can be given as:

\deqn{D[ij] = |I[ij] - M|}{D[ij] = |I[ij] - M|}

Distance-to-median decay function applies the exponential decay rate to each
distance to calculate the weights. Values close to the median (i.e., small
distances) will have weights approaching 1, whereas values further from the
median (i.e., large distances) will have weights approaching 0. The rate at
which the weights decrease as the distance increases is determined by the
\code{decay_rate}. A larger \code{decay_rate} results in a faster decrease
(i.e., weights will approach 0 more quickly), whereas a smaller
\code{decay_rate} results in a slower decrease (i.e., weights will stay
closer to 1 for larger distances). The decay_rate therefore controls the
weighting schema's sensitivity to the distance from the median. A higher
\code{decay_rate} increases the influence of indicators closer to the median.
A lower \code{decay_rate} mutes the effect of distance to the median, thereby
placing more equal weight across all values regardless of their distance from
the median. Denoting the decay rate as \eqn{\gamma}, the weight calculation
can be given as:

\deqn{w[ij] = exp(-\gamma * D[ij])}{w[ij] = exp(-gamma * D[ij])}

Unlike covariance or standard deviation based weighting schemas, the median
weighting schemas are unique to each respondent since it is possible for
respondents to have different medians. The distance-to-median weights are
normalized by dividing each weight by the mean of the weights: 

\deqn{w[j] = \frac{w[j]}{\frac{1}{m} \sum_{k=1}^{m} w[k]}}{w[j] = w[j] / (1/m
* sum(w[k] for k=1 to m))}

where \eqn{m} is the number of indicators, and the sum is taken over all
\eqn{k}. The distance-to-median composite score is then calculated as
follows:

\deqn{\bar{cs}[md] = \frac{1}{n} \sum_{i=1}^{n} I[i] * w_i}{composite_score_md = 1/n
* sum(df[i] * w_i for i=1 to n)}

where \eqn{\bar{cs}[md]} is the decay rate distance-to-median weighted
composite score.
}
\examples{

data(grit)

# Specify the named list with composite names and their respective indicators
composite_list <- composite_list(

  # Lower-order composites
  extraversion          = sprintf("e\%01d", seq(10)),
  neuroticism           = sprintf("n\%01d", seq(10)),
  agreeableness         = sprintf("a\%01d", seq(10)),
  conscientiousness     = sprintf("c\%01d", seq(10)),
  openness              = sprintf("o\%01d", seq(10)),
  consistency_interest  = sprintf("gs\%01d", c(2,3,5,7,8,11)),
  perseverance_effort   = sprintf("gs\%01d", c(1,4,6,9,10,12)),

  # Higher-order composites
  grit                  = c("consistency_interest", "perseverance_effort")

 )
                                   
# Calculate distance-to-median decay composite scores
dismed_decay_score(data = grit,
                   composite_list = composite_list,
                   decay_rate = 0.5)
                            
# Calculate distance-to-median decay composite scores, reliability, & validity
dismed_decay_score(data = grit,
                   composite_list = composite_list,
                   decay_rate = 0.5,
                   digits = 3,
                   return_metrics = TRUE,
                   file = "composite.xlsx")

unlink("composite.xlsx")

}
